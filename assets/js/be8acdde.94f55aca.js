"use strict";(self.webpackChunkmif_docs=self.webpackChunkmif_docs||[]).push([[181],{7496(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"features/expert_parallelism","title":"Expert parallelism","description":"Expert parallelism (EP) refers to a parallelization method that assigns and executes multiple experts of a Mixture-of-Experts (MoE) model across different GPUs. While applying EP is not mandatory for MoE models, it is generally helpful for increasing overall inference throughput (total output tokens per second).","source":"@site/versioned_docs/version-v0.0.0/features/expert_parallelism.md","sourceDirName":"features","slug":"/features/expert_parallelism","permalink":"/features/expert_parallelism","draft":false,"unlisted":false,"tags":[],"version":"v0.0.0","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Expert parallelism"},"sidebar":"docs","previous":{"title":"Prefill-decode disaggregation","permalink":"/features/prefill_decode_disaggregation"},"next":{"title":"Prefix cache-aware routing","permalink":"/features/prefix_cache_aware_routing"}}');var r=i(4848),a=i(8453);const s={sidebar_position:3,title:"Expert parallelism"},l="Expert parallelism",o={},c=[{value:"Key features",id:"key-features",level:2},{value:"Manual configuration of EP",id:"manual-configuration-of-ep",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"expert-parallelism",children:"Expert parallelism"})}),"\n",(0,r.jsx)(n.p,{children:"Expert parallelism (EP) refers to a parallelization method that assigns and executes multiple experts of a Mixture-of-Experts (MoE) model across different GPUs. While applying EP is not mandatory for MoE models, it is generally helpful for increasing overall inference throughput (total output tokens per second)."}),"\n",(0,r.jsx)(n.p,{children:"However, implementing EP efficiently is highly challenging because routing between different experts \u2014 and ultimately workload distribution across GPUs \u2014 is determined dynamically. GPU kernels and libraries must ensure good efficiency across a wide range of such cases. EP requires a complex all-to-all communication pattern known as dispatch and combine, where minimizing the associated overhead is critical. There is also an inherent imbalance in routing frequency among different experts, and it is crucial to maintain even workload distribution across GPUs despite these differences."}),"\n",(0,r.jsx)(n.p,{children:"In addition, while EP is effective for improving throughput, it can lead to higher latency compared to other parallelization methods such as tensor parallelism (TP). Therefore, it should be applied carefully according to the given service level objectives (SLOs) to achieve optimal results."}),"\n",(0,r.jsx)(n.h2,{id:"key-features",children:"Key features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["For various MoE models, the framework allows experts to be distributed across multiple GPUs within a single server or across GPUs in multiple servers. The ",(0,r.jsx)(n.strong,{children:"Odin"})," inference service manages the latter case by launching and coordinating multiple instances simultaneously when experts are distributed across servers."]}),"\n",(0,r.jsx)(n.li,{children:"The framework can automatically determine whether to apply EP and how to allocate experts to GPUs according to defined SLOs."}),"\n",(0,r.jsx)(n.li,{children:"Moreh vLLM is optimized to execute inter-GPU communication efficiently and minimize load imbalance across GPUs on AMD MI200 and MI300 series GPUs."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"manual-configuration-of-ep",children:"Manual configuration of EP"}),"\n",(0,r.jsxs)(n.p,{children:["To enable EP, add the ",(0,r.jsx)(n.code,{children:"--enable-expert-parallel"})," flag to the ",(0,r.jsx)(n.code,{children:"extraArgs"})," field of the ",(0,r.jsx)(n.strong,{children:"Odin"})," inference service. The following configuration file is an example of applying EP to the DeepSeek-R1 model. In vLLM, you don't need to explicitly specify the EP size and it is automatically calculated as DP size \xd7 TP size. This is because EP must be used with another parallelism scheme applied to non-expert layers (such as attention), and the possible options for that are DP or TP."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:"inference-service-values.yaml {4-8}",children:"\n...\nextraArgs:\n  - deepseek-ai/DeepSeek-R1\n  - --tensor-parallel-size\n  - '1'\n  - --data-parallel-size\n  - '8'\n  - --enable-expert-parallel\n\nextraEnvVars:\n  - name: VLLM_ROCM_USE_AITER\n    value: '1'\n  - name: VLLM_ALL2ALL_BACKEND\n    value: mori\n\n_resources: &resources\n  limits:\n    amd.com/gpu: '8'\n  requests:\n    amd.com/gpu: '8'\n...\n"})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>s,x:()=>l});var t=i(6540);const r={},a=t.createContext(r);function s(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);